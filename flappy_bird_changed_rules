#Department of Chemical Engineering
#Faculty of Engineering
#University of Waterloo
#December 2, 2025

#AJ = Arleen Johal, 21206994
#AK = Areebah Khokhar
#NKC = Natejvir Kaur Chahal, 21203534

#AREEBAH SECTION
#AK: Importing necessary python modules required for the game.
import csv
import random
import sys
from itertools import cycle

import pygame
from pygame.locals import QUIT, KEYDOWN, K_ESCAPE, K_SPACE, K_UP, K_p, K_r #Rule change 2 NKC: The Key "p" and "r" indicate pause and resume by player input.

import numpy as np

import datetime #Rule change 1 by NKC to determine current hour of player.

from PIL import Image, ImageEnhance #Rule change 1 by NKC to adjust background brightness.

#AK: Sets a seed for NumPy's pseudo-random number generator (to repeat numbers the same way each time).
np.random.seed(1)

#AK: Display settings for the game such as, screenwidth and screenheight 
FPS = 500
SCREENWIDTH  = 288
SCREENHEIGHT = 512
#AK: The distance between the lower and upper pipe 
PIPEGAPSIZE  = 100 
#AK: Where the bottom/grass is located on the screen
BASEY        = SCREENHEIGHT * 0.79

#AK: Dictionary for images, sound and hitmask variables
IMAGES, SOUNDS, HITMASKS = {}, {}, {}
paused = False #Change 2 by NKC: Not paused

#AK: Variables for the games learning system 
"""
learning
"""
statefile="state"
#AK: Flappy birds learning rate
alpha=1
#AK: Consideration of future rewards to be just as important as immediate rewards 
gamma=1
#AK: Reward for surviving 
survivereward = 1
#AK: Punishment for dying 
deadreward = -200
#AK: Reward for passing a set of pipes
passreward = 1
#AK: The birds memory of siutations and its performance
Qmatrix={}
#AK: Keeps track of high score
maxscore = 0
#AK: Counts total number of games played
wholecount = 0
#AK: Interval after which the time of the game updates
checktime=1
#AK: To define pixel value used for movement speed, size, or spacing 
pix=10
#AK: Flappy bird will only perform actions that it knows, it will never take random actions
epsilon=0
#AK: The amount by which epsilon is reduced 
eps_dec=0.0001

# list of all possible players (tuple of 3 positions of flap)
#AK: List of all possible bird displays/designs (there are 3 different wing positions) 
PLAYERS_LIST = (
    # red bird
    (
        'assets/sprites/redbird-upflap.png',
        'assets/sprites/redbird-midflap.png',
        'assets/sprites/redbird-downflap.png',
    ),
    # blue bird
    (
        # amount by which base can maximum shift to left
        'assets/sprites/bluebird-upflap.png',
        'assets/sprites/bluebird-midflap.png',
        'assets/sprites/bluebird-downflap.png',
    ),
    # yellow bird
    (
        'assets/sprites/yellowbird-upflap.png',
        'assets/sprites/yellowbird-midflap.png',
        'assets/sprites/yellowbird-downflap.png',
    ),
)

#AK: List if all the possible backgrounds (day or night)
BACKGROUNDS_LIST = (
    'assets/sprites/background-day.png',
    'assets/sprites/background-night.png',
)

#AK: List of all the possible pipe designs (red or green)
PIPES_LIST = (
    'assets/sprites/pipe-green.png',
    'assets/sprites/pipe-red.png',
)

#AK: Ensures xrange is compatible with Python 2 & Python 3 
try:
    xrange
except NameError:
    xrange = range

def main():
    global SCREEN, FPSCLOCK, paused_font #Rule change 2 by NKC: Ensures the local variable is accesible within the function.
    pygame.init() #Rule change 2 by NKC
    pygame.font.init() #Rule change 2 by NKC
    paused_font = pygame.font.SysFont(None, 50) #Rule change 2 by NKC
    FPSCLOCK = pygame.time.Clock()
    #AK: Creates the window/display for the game
    SCREEN = pygame.display.set_mode((SCREENWIDTH, SCREENHEIGHT))
    #AK: Displays the title at the top of the screen 
    pygame.display.set_caption('Flappy Bird')

    #AK: Number images to display the players score
    IMAGES['numbers'] = (
        pygame.image.load('assets/sprites/0.png').convert_alpha(),
        pygame.image.load('assets/sprites/1.png').convert_alpha(),
        pygame.image.load('assets/sprites/2.png').convert_alpha(),
        pygame.image.load('assets/sprites/3.png').convert_alpha(),
        pygame.image.load('assets/sprites/4.png').convert_alpha(),
        pygame.image.load('assets/sprites/5.png').convert_alpha(),
        pygame.image.load('assets/sprites/6.png').convert_alpha(),
        pygame.image.load('assets/sprites/7.png').convert_alpha(),
        pygame.image.load('assets/sprites/8.png').convert_alpha(),
        pygame.image.load('assets/sprites/9.png').convert_alpha()
    )

    #AK: Display to indicate that the game is over
    IMAGES['gameover'] = pygame.image.load('assets/sprites/gameover.png').convert_alpha()
    #AK: Display for welcoming player to the game
    IMAGES['message'] = pygame.image.load('assets/sprites/message.png').convert_alpha()
    #AK: Display for the ground 
    IMAGES['base'] = pygame.image.load('assets/sprites/base.png').convert_alpha()

    #AK: Depending on the device the player is using, this chooses a sound file to play 
    if 'win' in sys.platform:
        soundExt = '.wav'
    else:
        soundExt = '.ogg'
        
    #AK: Plays sound effects in the game 
    SOUNDS['die']    = pygame.mixer.Sound('assets/audio/die' + soundExt)
    SOUNDS['hit']    = pygame.mixer.Sound('assets/audio/hit' + soundExt)
    SOUNDS['point']  = pygame.mixer.Sound('assets/audio/point' + soundExt)
    SOUNDS['swoosh'] = pygame.mixer.Sound('assets/audio/swoosh' + soundExt)
    SOUNDS['wing']   = pygame.mixer.Sound('assets/audio/wing' + soundExt)

    def background_brightness(factor): #Rule change 1 by NKC
        background = Image.open('assets/sprites/background-day.png').convert("RGB") #Rule change 1 by NKC
        background_enhancer = ImageEnhance.Brightness(background) #Rule change 1 by NKC
        background_adjusted = background_enhancer.enhance(factor) #Rule change 1 by NKC
        mode = background_adjusted.mode #Rule change 1 by NKC: Convert PIL image to pygame surface format in order specify RGB
        size = background_adjusted.size #Rule change 1 by NKC: Convert PIL image to pygame surface format with tuple of dimensions
        data = background_adjusted.tobytes() #Rule change 1 by NKC: Convert PIL image to pygame surface format with string of pixels
        surface_background = pygame.image.fromstring(data,size,mode) #Rule change 1 by NKC: Use data to convert from PIL image to pygame surface format
        return surface_background #Rule change 1 by NKC: Final background in pygame surface format
    
    def background_time(): #Rule change 1 by NKC
        player_current_hour = datetime.datetime.now().hour #Rule change 1 by NKC: Hours in military time
        if 6 <= player_current_hour < 17: #Rule change 1 by NKC: 6:00 A.M. to 5:00 P.M.
            return background_brightness(1) #Rule change 1 by NKC: factor of 1 = standard during daytime
        elif 17 <= player_current_hour < 18: #Rule change 1 by NKC: 5:00 P.M. to 6:00 P.M.
            return background_brightness(0.5) #Rule change 1 by NKC: factor less than 1 = darker durig sunset
        elif (18 <= player_current_hour <= 23) or (0 <= player_current_hour < 5): #Rule change 1 by NKC: 6:00 P.M. to 11:00 P.M. or 12:00 A.M. to 5:00 A.M.
            return background_brightness(0.3) #Rule change 1 by NKC: factor less than 1 = darker during ight
        else: # Rule change 1 by NKC: if 5 <= player_current_hour < 6:
            #Rule change 1 by NKC: 5:00 A.M. to 6:00 A.M.
            return background_brightness(0.7) #Rule change 1 by NKC: factor less than 1 = darker during sunrise

    def draw_background(): #Rule change 2 by NKC: Function to reduce lines of code
        if not paused: #Rule change 2 by NKC
            SCREEN.blit(IMAGES['background'], (0,0)) #Rule change 2 by NKC: Standard background
        else: #Rule change 2 by NKC: If paused
            SCREEN.blit(IMAGES['dimmed'], (0,0)) #Rule change 2 by NKC: Darker background to distinguish game paused to player.
            paused_label = paused_font.render("PAUSED", True, (255,255,255)) #Rule change 2 by NKC: High-contrast white label on darker background to inform player that the game is paused.
            SCREEN.blit(paused_label, (SCREENWIDTH//2 - paused_label.get_width()//2, SCREENHEIGHT//2 - paused_label.get_height()//2)) #Rule change 2 by NKC: Positions label in middle of screen.
        
    #AK: A loop that restarts the game once it has ended
    while True:
        paused = False #Rule change 2 by NKC: Game is not paused by player
        
        #AK: Selects a random background 
        randBg = 0
        IMAGES['background'] = pygame.image.load(BACKGROUNDS_LIST[randBg]).convert()
        IMAGES['dimmed'] = background_brightness(0.2) #Rule change 2 by NKC: Background when game paused by player is adjusted to be darker. This distinguishes that the game has been paused as the game contents is not clearly visible.

        #AK: Selects a random bird display (between 3 positions)
        randPlayer = 0
        IMAGES['player'] = (
            pygame.image.load(PLAYERS_LIST[randPlayer][0]).convert_alpha(),
            pygame.image.load(PLAYERS_LIST[randPlayer][1]).convert_alpha(),
            pygame.image.load(PLAYERS_LIST[randPlayer][2]).convert_alpha(),
        )

        #AK: Selects random pipes to display (the top pipe is the bottom just rotated)
        pipeindex = 0
        IMAGES['pipe'] = (
            pygame.transform.rotate(
                pygame.image.load(PIPES_LIST[pipeindex]).convert_alpha(), 180),
            pygame.image.load(PIPES_LIST[pipeindex]).convert_alpha(),
        )

        # hismask for pipes
        #AK: Makes hitmasks that allows the game to detect when pixels collide with each other (ex. flappy bird hitting the pipe) 
        HITMASKS['pipe'] = (
            getHitmask(IMAGES['pipe'][0]),
            getHitmask(IMAGES['pipe'][1]),
        )

        HITMASKS['player'] = (
            getHitmask(IMAGES['player'][0]),
            getHitmask(IMAGES['player'][1]),
            getHitmask(IMAGES['player'][2]),
        )
        #AK: Displays the starting screen that welcomes the player
        movementInfo = showWelcomeAnimation()
        #AK: Begins the main game
        crashInfo = mainGame(movementInfo)
        #showGameOverScreen(crashInfo)

def draw_background(): #Rule change 2 by NKC: Function to reduce lines of code
        if not paused: #Rule change 2 by NKC
            SCREEN.blit(IMAGES['background'], (0,0)) #Rule change 2 by NKC: Standard background
        else: #Rule change 2 by NKC: If paused
            SCREEN.blit(IMAGES['dimmed'], (0,0)) #Rule change 2 by NKC: Darker background to distinguish game paused to player.
            paused_label = paused_font.render("PAUSED", True, (255,255,255)) #Rule change 2 by NKC: High-contrast white label on darker background to inform player that the game is paused.
            SCREEN.blit(paused_label, (SCREENWIDTH//2 - paused_label.get_width()//2, SCREENHEIGHT//2 - paused_label.get_height()//2)) #Rule change 2 by NKC: Positions label in middle of screen.

def showWelcomeAnimation():
    """Shows welcome screen animation of flappy bird"""
    # index of player to blit on screen
    #AK: Which position the bird will be displayed (out of its three wing positions)
    playerIndex = 0
    playerIndexGen = cycle([0, 1, 2, 1])
    loopIter = 0
    
    #AK: Where the bird and message are initially located on the display screen 
    playerx = int(SCREENWIDTH * 0.2)
    playery = int((SCREENHEIGHT - IMAGES['player'][0].get_height()) / 2)

    messagex = int((SCREENWIDTH - IMAGES['message'].get_width()) / 2)
    messagey = int(SCREENHEIGHT * 0.12)

    basex = 0

    #AK: Used to make th eground pass/scroll by smoothly 
    baseShift = IMAGES['base'].get_width() - IMAGES['background'].get_width()

    #AK: How much the bird animation floats up and down on the welcome screen
    playerShmVals = {'val': 0, 'dir': 1}


    #AK: Frequently updates the birds animation 
    if (loopIter + 1) % 5 == 0:
        playerIndex = next(playerIndexGen)
    loopIter = (loopIter + 1) % 30
    basex = -((-basex + 4) % baseShift)
    #AK: Allows the bird to float upwards & downwards
    playerShm(playerShmVals)

    global paused #Rule change 2 by NKC: Ensures the local variable is accesible within the function.
    
    #AK: Draws all the sprites on the screen 
    draw_background() #Rule change 2 by NKC
    
    SCREEN.blit(IMAGES['player'][playerIndex],
                (playerx, playery + playerShmVals['val']))
    SCREEN.blit(IMAGES['message'], (messagex, messagey))
    SCREEN.blit(IMAGES['base'], (basex, BASEY))

    pygame.display.update()
    FPSCLOCK.tick(FPS)

    #AK: Returns the birds position at the start of each game
    return {
        'playery': playery + playerShmVals['val'],
        'basex': basex,
        'playerIndexGen': playerIndexGen,
        'playerIndex': playerIndex
    }

#ARLEEN'S SECTION 
def mainGame(movementInfo):
    global wholecount,maxscore,epsilon,paused #Rule change 2 by NKC: Ensures the local variable is accesible within the function.

    score = loopIter = 0
    playerIndexGen = movementInfo['playerIndexGen']
    playerIndex =movementInfo['playerIndex']
    playerx, playery = int(SCREENWIDTH * 0.2), movementInfo['playery']

    basex = movementInfo['basex']
    baseShift = IMAGES['base'].get_width() - IMAGES['background'].get_width()

    # get 2 new pipes to add to upperPipes lowerPipes list
    newPipe1 = getRandomPipe()
    newPipe2 = getRandomPipe()

    # list of upper pipes
    upperPipes = [
        {'x': SCREENWIDTH, 'y': newPipe1[0]['y']},
        {'x': SCREENWIDTH + (SCREENWIDTH / 2), 'y': newPipe2[0]['y']},
    ]

    # list of lowerpipe
    lowerPipes = [
        {'x': SCREENWIDTH, 'y': newPipe1[1]['y']},
        {'x': SCREENWIDTH + (SCREENWIDTH / 2), 'y': newPipe2[1]['y']},
    ]

    base_pipeVelX = -4 #Rule change 3 by NKC: Standard inital pipe velocity
    result_pipeVelX = base_pipeVelX - score//10 #Rule change 3 by NKC: Current pipe velocity increases per ten points gained by player.

    # player velocity, max velocity, downward accleration, accleration on flap
    playerVelY    =  -9   # player's velocity along Y, default same as playerFlapped
    playerMaxVelY =  10   # max vel along Y, max descend speed
    playerMinVelY =  -8   # min vel along Y, max ascend speed
    playerAccY    =   1   # players downward accleration
    playerRot     =  45   # player's rotation
    playerVelRot  =   3   # angular speed
    playerRotThr  =  20   # rotation threshold
    playerFlapAcc =  -9   # players speed on flapping
    playerFlapped = False # True when player flaps

    pipew=IMAGES['pipe'][0].get_width()
    playerw=IMAGES['player'][0].get_width()
    playerh=IMAGES['player'][0].get_height()

    count = 0
    pipepass=False
    dx = int(lowerPipes[0]['x'] + pipew - (playerx + playerw))
    dy = int(lowerPipes[0]['y'] - (playery + playerh))
    dx = dx / pix
    dy = dy / pix
    dist = (dx, dy)
    last=dist

    while True:
        count += 1
        for event in pygame.event.get():
            if event.type == KEYDOWN and event.key == K_p: #Rule change 2 by NKC: If player presses down on the key "p" to indicate pause game
                paused = not paused #Rule change 2 by NKC: Game is paused as pause = True (not False)
            if event.type == KEYDOWN and event.key == K_r: #Rule change 2 by NKC: If player presses down on the key "r" to indicate reusme game
                paused = False #Rule change 2 by NKC: Game is not paused
            if event.type == QUIT or (event.type == KEYDOWN and event.key == K_ESCAPE):
                with open(statefile,'wb') as wf:
                    w=csv.writer(wf)
                    w.writerows(Qmatrix.items())
                with open("score.csv",'wb') as wf:
                    w=csv.writer(wf)
                    w.writerow((maxscore,wholecount))
                pygame.quit()
                sys.exit()

        playerMidPos = playerx
        # update last state
        for pipe in lowerPipes:
            pipeMidPos = pipe['x'] + IMAGES['pipe'][0].get_width()
            if playerMidPos < pipeMidPos:
                break

        dx = int(pipe['x'] + pipew - (playerx + playerw))
        dy = int(pipe['y'] - (playery + playerh))
        dx = dx / pix
        dy = dy / pix
        dist = (dx, dy)
        if dist not in Qmatrix:
            Qmatrix[dist] = [0, 0]
        if np.random.uniform()<epsilon:
            action=np.random.randint(2)
        else:
            action = Qmatrix[dist].index(max(Qmatrix[dist]))
        epsilon=max(epsilon-eps_dec,0)
        if action == 1:
            if playery > -2 * IMAGES['player'][0].get_height():
                playerVelY = playerFlapAcc
                playerFlapped = True


        # playerIndex basex change
        if (loopIter + 1) % 3 == 0:
            playerIndex = next(playerIndexGen)
        loopIter = (loopIter + 1) % 30
        basex = -((-basex + 4) % baseShift)

        # rotate the player
        if playerRot > -90:
            playerRot -= playerVelRot

        # player's movement
        if playerVelY < playerMaxVelY and not playerFlapped:
            playerVelY += playerAccY
        if playerFlapped:
            playerFlapped = False

            # more rotation to cover the threshold (calculated in visible rotation)
            playerRot = 45

        playerHeight = IMAGES['player'][playerIndex].get_height()
        playery += min(playerVelY, BASEY - playery - playerHeight)

        if not paused: #Rule change 2 by NKC: If the game is not paused:
            result_pipeVelX = max(-10, base_pipeVelX - score//10) #Rule change 3 by NKC: Verify that the current pipe horizontal velocity cannot exceed maximum horizontal velocity of bird.

        # move pipes to left
        for uPipe, lPipe in zip(upperPipes, lowerPipes):
            uPipe['x'] += result_pipeVelX #Rule change 3 by NKC
            lPipe['x'] += result_pipeVelX #Rule change 3 by NKC

        # add new pipe when first pipe is about to touch left of screen
        if 0 < upperPipes[0]['x'] < 5:
            newPipe = getRandomPipe()
            upperPipes.append(newPipe[0])
            lowerPipes.append(newPipe[1])

        # remove first pipe if its out of the screen
        if upperPipes[0]['x'] < -IMAGES['pipe'][0].get_width():
            upperPipes.pop(0)
            lowerPipes.pop(0)

        # draw sprites
        draw_background() #Rule change 2 by NKC

        for uPipe, lPipe in zip(upperPipes, lowerPipes):
            SCREEN.blit(IMAGES['pipe'][0], (uPipe['x'], uPipe['y']))
            SCREEN.blit(IMAGES['pipe'][1], (lPipe['x'], lPipe['y']))

        SCREEN.blit(IMAGES['base'], (basex, BASEY))
        # print score so player overlaps the score
        showScore(score)

        # Player rotation has a threshold
        visibleRot = playerRotThr
        if playerRot <= playerRotThr:
            visibleRot = playerRot

        playerSurface = pygame.transform.rotate(IMAGES['player'][playerIndex], visibleRot)
        SCREEN.blit(playerSurface, (playerx, playery))

        pygame.display.update()

        # check for crash here
        crashTest = checkCrash({'x': playerx, 'y': playery, 'index': playerIndex},
                               upperPipes, lowerPipes)
        if crashTest[0]:
            reward=deadreward
            wholecount += 1
        else:
            reward=survivereward
            # check for score
            playerMidPos = playerx + IMAGES['player'][0].get_width() / 2
            for pipe in upperPipes:
                pipeMidPos = pipe['x'] + IMAGES['pipe'][0].get_width() / 2
                if pipeMidPos <= playerMidPos < pipeMidPos + 4:
                    score += 1
                    if score > maxscore:
                        maxscore = score
                        with open(statefile, 'wb') as wf:
                            w = csv.writer(wf)
                            w.writerows(Qmatrix.items())
                    pipepass=True
                    reward=passreward
                    #SOUNDS['point'].play()

        """
        update
        """
        playerMidPos = playerx
        # update last state
        for pipe in lowerPipes:
            pipeMidPos = pipe['x'] + IMAGES['pipe'][0].get_width()
            if playerMidPos < pipeMidPos:
                break

        dx = int(pipe['x'] + pipew - (playerx + playerw))
        dy = int(pipe['y'] - (playery + playerh))
        dx = dx / pix
        dy = dy / pix
        dist = (dx, dy)
        if dist not in Qmatrix:
            Qmatrix[dist] = [0, 0]
        maxnewstate = max(Qmatrix[dist])
        Qmatrix[last][action] = (1 - alpha) * Qmatrix[last][action] + alpha * (reward + gamma * maxnewstate)
        last = dist

        if crashTest[0]:
            return {
                'y': playery,
                'groundCrash': crashTest[1],
                'basex': basex,
                'upperPipes': upperPipes,
                'lowerPipes': lowerPipes,
                'score': score,
                'playerVelY': playerVelY,
                'playerRot': playerRot
            }

        FPSCLOCK.tick(FPS)


#NAVTEJVIR'S SECTION 
def showGameOverScreen(crashInfo):
    """crashes the player down and shows gameover image"""
    global paused #Rule change 2 by NKC: Ensures the local variable is accesible within the function.
    
    score = crashInfo['score'] #NKC: From crashInfo dictionary, score value is assigned to display final score to player
    playerx = SCREENWIDTH * 0.2 #NKC: Bird position is determined to be 20% of screenwidth. Position to left ensures time for user to predict action according to obstacles to the right/ahead.
    playery = crashInfo['y'] #NKC: Current vertical coordinate of bird in crashInfo recorded prior to crash in order to commence and continue at approperite positon following crash.
    playerHeight = IMAGES['player'][0].get_height() #NKC: Bird height is determined as the the height of the first bird image in order to determine if bird comes into contact with obstacles.
    playerVelY = crashInfo['playerVelY'] #NKC: Vertical velocity ensures consistent animation of crash.
    playerAccY = 2 #NKC: Graviational acceleration to ensure descent of bird. Value of 2 ensures consistent animation with sufficient reaction time for player.
    playerRot = crashInfo['playerRot'] #NKC: Rotation angle determined from rotation angle of crash.
    playerVelRot = 7 #NKC: Rotational velocity for consistent animation of loss of control to user.

    basex = crashInfo['basex'] #NKC: Current horizontal coordinate of bird in crashInfo recorded at crash in order to commence and continue at approperiate position following crash.

    upperPipes, lowerPipes = crashInfo['upperPipes'], crashInfo['lowerPipes'] #NKC: Redraw pipes according to positions at the time of the crash.

    # play hit and die sounds
    SOUNDS['hit'].play() #NKC: 'hit' audio in SOUNDS dictionary played using method.
    if not crashInfo['groundCrash']: #NKC: Determine if crash with pipe to play approperiate audio.
        SOUNDS['die'].play() #NKC: 'die' audio in SOUNDS dictionary played using method. Different sound emphazies emotional impact to indicate game loss in contrast to hit.

    while True: #NKC: Initates infinte loop to remain in game-over display until player inputs decision to restart or quit.
        for event in pygame.event.get(): #NKC: Retrieves and processes all player inputs/actions.
            if event.type == QUIT or (event.type == KEYDOWN and event.key == K_ESCAPE):#NKC: Player quits (close window, escape key)
                pygame.quit() #NKC: Closes game
                sys.exit() #NKC: Exits program
            if event.type == KEYDOWN and (event.key == K_SPACE or event.key == K_UP): #NKC: Player restarts (space bar, up arrow)
                if playery + playerHeight >= BASEY - 1: #NKC: Compares vertical coordinate of bird to ground position to ensure restarts following crash/contact with ground.
                    return #NKC: Exit game-over display to restart

        # player y shift
        if playery + playerHeight < BASEY - 1: #NKC: Verifies if bird is above ground, so possibility of descent is physically possible.
            playery += min(playerVelY, BASEY - playery - playerHeight) #NKC: Updates vertical coordinate of bird according to smallest value of either vertical velcoity or distance from ground. Minimum value prevents bird surpassing ground depth.

        # player velocity change
        if playerVelY < 15: #NKC: Verifies that vertical velocity does not surpass maximum of 15.
            playerVelY += playerAccY #NKC: Increases vertical velocity by acceleration due to gravity for consistent descent animation.

        # rotate only when it's a pipe crash
        if not crashInfo['groundCrash']: #NKC: Verifies crash with pipe, so rotation required.
            if playerRot > -90: #NKC: Verification of current rotation of bird compared with limit of -90 degrees (90 degree rotation clockwise rsults in pointing straight down).
                playerRot -= playerVelRot #NKC: If rotation surpasses limit, current rotation is reduced by rotation velocity.

        #NKC: Draw sprites (two dimensional image)
        draw_background() #Rule change 2 by NKC

        for uPipe, lPipe in zip(upperPipes, lowerPipes): #NKC: All pipes redrawn for collision
            SCREEN.blit(IMAGES['pipe'][0], (uPipe['x'], uPipe['y'])) #NKC: Retrieves pipe sprite from IMAGE dictionary to display at location determined by dictionary values of horizontal and vertical coordinates.
            SCREEN.blit(IMAGES['pipe'][1], (lPipe['x'], lPipe['y']))

        SCREEN.blit(IMAGES['base'], (basex, BASEY)) #NKC: Redraws ground sprite at horixontal and vertical fixed coordinates.
        showScore(score) #NKC: Displays current score to player to inform regarding performance.

        playerSurface = pygame.transform.rotate(IMAGES['player'][1], playerRot) #NKC: Current rotation angle applied to bird sprite from IMAGES dictionary.
        SCREEN.blit(playerSurface, (playerx,playery)) #NKC: Rotated bird sprite displayed at horizontal and vertical coordinates for consistent animation of crash.

        FPSCLOCK.tick(FPS) #NKC: Limits frame display rate so all animations change display smoothly.
        pygame.display.update() #NKC: Displays updated frame to player.

def playerShm(playerShm):
    """oscillates the value of playerShm['val'] between 8 and -8"""
    if abs(playerShm['val']) == 8: #NKC: If oscillation of bird in one direction reaches maximum (-8 or 8), must reverse direction.
        playerShm['dir'] *= -1 #NKC: Reverses oscillation direction of bird.
        #NKC: Oscillation provides consistent natural animation of bird movement.

    if playerShm['dir'] == 1: #NKC: Verifies if direction key of playerShm dictionary is up (1).
         playerShm['val'] += 1 #NKC: Increases vertical displacement by 1, so bird increases vertical position in each frame.
    else: #NKC: Otherwise (if not moving up), vertical direction of bird is down.
        playerShm['val'] -= 1 #NKC: Decreases vertical displacement by 1, so bird decreases vertical position in each frame.

def getRandomPipe():
    """returns a randomly generated pipe"""
    # y of gap between upper and lower pipe
    gapY = random.randrange(0, int(BASEY * 0.6 - PIPEGAPSIZE)) #NKC: Generates random vertical position for pipe gap within range of playable area of display.
    #NKC: Playable area is in vertical range above 60% of ground, accounting for sufficient space for the determined size of the gap.
    gapY += int(BASEY * 0.2) #lower 0.2~0.8 pipe
    #NKC: Ensures gap remains within 20% to 80% of screen height for safe passage of bird by player.
    pipeHeight = IMAGES['pipe'][0].get_height()  #NKC: Retrieves height of pipe sprite to determine correct position on display.
    pipeX = SCREENWIDTH + 10 #NKC: Positions pipe sprite beyond screen display boundary towards right to ensure consistent enterance animation during gameplay.

    return [
        {'x': pipeX, 'y': gapY - pipeHeight},  # upper pipe above gap
        {'x': pipeX, 'y': gapY + PIPEGAPSIZE}, # lower pipe below gap
    ]


def showScore(score):
    """displays score in center of screen"""
    scoreDigits = [int(x) for x in list(str(score))] #NKC: Converts/splits score into list of digits for individual display of digits.
    totalWidth = 0 #NKC: Total width of all numbers to be printed.

    for digit in scoreDigits: #NKC: Calculates total width of score to ensure display in centre.
        totalWidth += IMAGES['numbers'][digit].get_width() #NKC: Width of each individual digit sprite from IMAGES dictionary is summed to determine total width of score.

    Xoffset = (SCREENWIDTH - totalWidth) / 2 #NKC: Calculates horizontal centre position of score by calculating the midpoint between the difference of the screen width and score width.

    for digit in scoreDigits: #NKC: Loop to display each digit.
        SCREEN.blit(IMAGES['numbers'][digit], (Xoffset, SCREENHEIGHT * 0.1)) #NKC: Displays each digit sprite at the calculated horizontal centre position and fixed vertical position (10% below screen height/top).
        Xoffset += IMAGES['numbers'][digit].get_width() #NKC: Increases horizontal position by current digit width in order to determine horizontal position of next digit.


def checkCrash(player, upperPipes, lowerPipes):
    """returns True if player collides with base or pipes."""
    pi = player['index'] #NKC: Current bird animation frame (with regard to wing position) retrieved from player dictionary at time of possible crash.
    player['w'] = IMAGES['player'][0].get_width() #NKC: Stores width of bird sprite.
    player['h'] = IMAGES['player'][0].get_height() #NKC: Stores height of bird sprite.
    #NKC: Note that the dimensions of the bird sprite are recorded in order to determine if the bird overlaps/crashes into other obstacles (the ground or pipes).

    # if player crashes into ground
    if player['y'] + player['h'] >= BASEY - 1: #NKC: Verifies if the bottom vertical position (top vertical position - height) of the bird sprite is at or surpasses ground depth.
        return [True, True] #NKC: Crash occurs with ground
    else:
        playerRect = pygame.Rect(player['x'], player['y'],
                      player['w'], player['h']) #NKC: Creates a rectangle commencing at the left horizontal position extended by the width; the top vertical position extended by the height of the bird animation sprite.
        pipeW = IMAGES['pipe'][0].get_width() #NKC: Retrieves and stores width of pipe sprite from IMAGE dictionary to chcek for overlap indicating crash.
        pipeH = IMAGES['pipe'][0].get_height() #NKC: Retrieves and stores height of pipe sprite from IMAGE dictionary to chcek for overlap indicating crash.

        for uPipe, lPipe in zip(upperPipes, lowerPipes): #NKC: Multiple assignment enhances efficiency and readability
            # upper and lower pipe rects
            uPipeRect = pygame.Rect(uPipe['x'], uPipe['y'], pipeW, pipeH) #NKC: Creates a rectangle commencing at the left horizontal position extended by the width; the top vertical position extended by the height of the upper pipe sprite.
            lPipeRect = pygame.Rect(lPipe['x'], lPipe['y'], pipeW, pipeH) #NKC: Creates a rectangle commencing at the left horizontal position extended by the width; the top vertical position extended by the height of the lower pipe sprite.

            # player and upper/lower pipe hitmasks
            #NKC: Hitmasks mark where pixels of sprite are solid vs transparent.
            pHitMask = HITMASKS['player'][pi]
            uHitmask = HITMASKS['pipe'][0]
            lHitmask = HITMASKS['pipe'][1]

            # if bird collided with upipe or lpipe
            #NKC: As a reuslt, crash is registered according to the overlap of solid pixels of sprites.
            uCollide = pixelCollision(playerRect, uPipeRect, pHitMask, uHitmask)
            lCollide = pixelCollision(playerRect, lPipeRect, pHitMask, lHitmask)

            if uCollide or lCollide: #If crash occurs between upper pipe or lower pipe
                return [True, False] #Crash occurs with pipe (not ground)

    return [False, False] #No crash (with ground or pipe)
    #NKC: Note that the first boolean value confirms whether a crash has occured or not; whereas, the second boolean value indicates the type of crash.

def pixelCollision(rect1, rect2, hitmask1, hitmask2):
    """Checks if two objects collide and not just their rects"""
    rect = rect1.clip(rect2) #NKC: Determines overlap between two rectangles

    if rect.width == 0 or rect.height == 0: #NKC: If either dimension of rectangle are 0, there is no overlap.
        return False #NKC: No overlap indicates that objects do not collide.
        
    #NKC: Positions of overlapping pixels of sprites
    x1, y1 = rect.x - rect1.x, rect.y - rect1.y
    x2, y2 = rect.x - rect2.x, rect.y - rect2.y

    for x in xrange(rect.width): #NKC: Scan each overlap pixel horizontally
        for y in xrange(rect.height): #NKC: Scan each overlap pixel vertically
            if hitmask1[x1+x][y1+y] and hitmask2[x2+x][y2+y]:
                return True #NKC: If any pixels of overlap are solid, objects collide.
    return False #NKC: If any pixels of overlap are transparent, objects do not collide.

def getHitmask(image):
    """returns a hitmask using an image's alpha."""
    mask = []
    for x in xrange(image.get_width()): #NKC: Scan each overlap pixel horizontally
        mask.append([])
        for y in xrange(image.get_height()): #NKC: Scan each overlap pixel vertically
            mask[x].append(bool(image.get_at((x,y))[3]))
    return mask

if __name__ == '__main__': #NKC: When program is run directly/scripted (not imported) the following is executed:
    main() #NKC: Main game loop
